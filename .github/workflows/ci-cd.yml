name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    steps:
      # Шаг 1: Клонирование репозитория
      - name: Checkout repository
        uses: actions/checkout@v3

      # Шаг 2: Настройка Docker Buildx для современных возможностей сборки
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Шаг 3: Аутентификация в Yandex Container Registry
      - name: Login to Container Registry
        run: |
          echo "${{ secrets.YC_CR_TOKEN }}" | docker login --username iam --password-stdin cr.yandex

      # Шаг 4: Сборка и отправка Docker-образа
      - name: Build and push Docker image
        uses: docker/build-push-action@v3
        with:
          context: ./container
          file: ./container/Dockerfile
          push: true
          # Здесь переменная secrets.YC_REGISTRY_ID содержит ID реестра, а
          # my-test-app – имя образа; tag может быть "latest" или версионным.
          tags: cr.yandex/${{ secrets.YC_REGISTRY_ID }}/my-test-app:1.0.0
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Kubernetes
    needs: build
    runs-on: ubuntu-latest
    env:
      KUBECONFIG: ${{ github.workspace }}/kubeconfig.yaml
    steps:
      # Шаг 1: Клонирование репозитория (если требуется для доступа к манифестам)
      - name: Checkout repository
        uses: actions/checkout@v3

      # # Шаг 2: Установка Helm – пакетный менеджер для Kubernetes
      # - name: Setup Helm
      #   uses: azure/setup-helm@v1
      #   with:
      #     version: 'v3.7.0'

      # Шаг 2: Установка kubectl – клиент для управления кластером Kubernetes
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.29.0'  # выберите версию, соответствующую вашему кластеру

      # Шаг 3: Конфигурация доступа к вашему Kubernetes кластеру
      # Здесь предполагается, что содержимое kubeconfig вы храните в секрете с именем KUBE_CONFIG
      - name: Configure kubeconfig
        run: |
          printf "%b" "${{ secrets.KUBE_CONFIG }}" > kubeconfig.yaml
          kubectl config use-context default --kubeconfig=$KUBECONFIG
          kubectl get namespace --kubeconfig=$KUBECONFIG

      # - name: Add Helm Repositories & Update
      #   run: |
      #     helm repo add external-secrets https://charts.external-secrets.io
      #     helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
      #     helm repo update

      # - name: Clone kube-prometheus repository
      #   run: |
      #     # Клонируем репозиторий prometheus-operator, если его ещё нет
      #     rm -rf k8s/kube-prometheus || true
      #     git clone https://github.com/prometheus-operator/kube-prometheus.git k8s/kube-prometheus

      # - name: Deploy Prometheus Operator (kube-prometheus)
      #   run: |
      #     # Применяем предварительную настройку с server-side apply
      #     kubectl apply --server-side -f k8s/kube-prometheus/manifests/setup
      #     # Ждём, пока все CRD окажутся установлены (можно изменить namespace, если требуется)
      #     kubectl wait --for condition=Established --all CustomResourceDefinition --namespace=monitoring
      #     # Применяем остальные манифесты
      #     kubectl apply -f k8s/kube-prometheus/manifests/

      # - name: Install External-Secrets Helm Chart
      #   run: |
      #     helm install external-secrets external-secrets/external-secrets --namespace external-secrets --create-namespace

      # - name: Create Namespace "ns" and Secret for YC Auth
      #   run: |
      #     # Создание namespace, если он ещё не существует
      #     kubectl apply -f - <<EOF
      #     apiVersion: v1
      #     kind: Namespace
      #     metadata:
      #       name: ns
      #     EOF
      #     # Создаем секрет yc-auth. Если секрет уже существует, команда вернет ошибку - добавляем || echo
      #     kubectl --namespace ns create secret generic yc-auth --from-file=authorized-key=.authorized_key.json || echo "Secret yc-auth already exists"
      
      # - name: Install Ingress-Nginx Helm Chart with Custom Default SSL Certificate
      #   run: |
      #     helm install ingress-nginx ingress-nginx/ingress-nginx \
      #       --namespace ns \
      #       --set controller.extraArgs.default-ssl-certificate="ns/k8s-secret" || \
      #     helm upgrade ingress-nginx ingress-nginx/ingress-nginx \
      #       --namespace ns \
      #       --set controller.extraArgs.default-ssl-certificate="ns/k8s-secret"

      # Шаг 4: Обновление приложения в кластере (например, обновление образа в Deployment)
      - name: Deploy new image to Kubernetes
        run: |
          kubectl set image deployment/nginx-deployment \
            nginx=cr.yandex/${{ secrets.YC_REGISTRY_ID }}/my-test-app:1.0.0 \
            --namespace=ns --kubeconfig=$KUBECONFIG
